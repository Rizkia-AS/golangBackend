0. TIAP LANGKAH DIBAWAH SEKALIAN MEMBUAT MAKEFILE

1. buat kode sql secara manual (
    - tabel-tabel
    - relasi antar tabel atau setup foreign key
    - setup indexing pada tiap table

) atau bisa menggunakan design database di dbdiagram.io

2. setup postgress di docker atau podman


3. setup database migration (
    - buat folder db > migration
    - schema up (salinan dari kode sql)
    - schema down (lawan dari schema up)
)

4. running postgress pada docker atau podman
    - podman run --name ps15 -p 5432:5432 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=21204444 -d docker.io/library/postgres:15.2-alpine

5. lakukan migration up
    - migrate -path db/migration -database "postgresql://root:21204444@localhost:5432/bank_mandiri?sslmode=disable" -verbose up

6. generate kode CRUD menggunakan sqlc (
    - https://docs.sqlc.dev/en/stable/tutorials/getting-started-postgresql.html
    - setting configuration, gunakan v1 saja untuk template ada di web nya
    - buat folder db > query untuk menyimpan kode sql untuk setiap table
    - buat folder db > sqlc untuk menyimpan kode generate hasil proses sqlc
    - sqlc init untuk Create an empty sqlc.yaml settings file
    - sqlc generate
)

7. buat testing

8. buat transaction (transfer contohnya)

9. buat testing

10. setting sql agar tau bahwa jika kita ingin melakukan transaction maka yang berubah hanya balance nya saja dan tidak merubah key. hal ini berguna untuk melakukan transcation secara concurent 
SELECT * FROM accounts
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE;

11. buat testing

12. ubah kode transcation agar secara concurent dapat melayani permintaan transfer dari akun 1 ke akun 2 dan juga sebaliknya akun 2 ke akun 1 secara bersaamaan

13. buat testing

14 buat CI dan CD dengan github action

15. buat rest api menggunakan GIN

16. setup Viper untuk memuat konfigurasi dari environtment variables atau file\
    a. kenapa memuat file konfigurasi dari file
        - easily specify default configuration for local development or testing

    b. kenapa memuat konfigurasi dari environtment variables
        - will help us easily overrie the default configurations when deploy with docker containers when deploying our application for stagging or production

    1. buat app.env dan simpan konfig disitu
    2. buat config.go di util 

17. testing lagi (mock database) menggunakan gomock

    a. why mock database ?
    1. independent test
        isolate test data from real database to avoid conflicts

    2. faster test
        reduce  a lot of time talking to the database. karna test tidak harus menghabiskan banyak waktu talking to the db dan menunggu query untuk berjalan. semua action akan di lakukan di memory dalam proses yang sama

    3. 100% coverage
        easily setup edge cases: unexpected errors

mock db & real db should implement the same interface

    a. how to mock ?
     1. user fake db : memory
        implement a fake version of db: store data in memory. kekurangannya kita harus menuliskan banyak kode yang hanya digunakan untuk testing

     2. user db strub : gomock
        generate and build stubs that return hard coded value

apakah sudah cukup jika kita menggunakan mock ? 
ya karena database kita yang asli sudah kita pernah tes sebelumnya

langkah langhkah :
    1. mockgen backendmaster/db/sqlc ==> karena store terletak di db/sqlc
    mockgen -package mockdb -destination db/mock/store.go backendmaster/db/sqlc Store

18. buat rest api untuk transfers

19. buat custom validator

20. buat table users dan perbarui schema migration

    langkah-langkah memperbaharui migration
    1. generate new version of migration 
        migrate create -ext sql -dir db/migration -seq add_users 
    
    2. isi migration yang baru dengan sql yang baru saja, jika ada kode yang mirip kode lama tidak perlu karna sudah ada dimig lama dan hal itu akan membuat konflik

    3. lakukan migdown
        saat pertama kali pembuatan table harus dipikirkan dengan baik" bagaimana schema database tersebut. karena kadang penambahan table dengan constraint ke table lama akan menimbulkan konflik jika isi dari table lama tersebut tidak memiliki constraint ke isi dari table baru

        hal itu membuat kita harus melakukan migdown yang mana akan menghapus data yg sudah pernah diinputkan sebelumnya. hal ini akan sangat beresiko jika program sudah pada tahap production 

    4. lakukan migup
